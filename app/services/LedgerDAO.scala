package services

import java.sql.{Date, Timestamp}
import java.time.LocalDate
import javax.inject.{Inject, Singleton}

import com.sun.javafx.logging.Logger
import models._
import play.api.db.slick.DatabaseConfigProvider
import slick.driver.JdbcProfile
import slick.model.Column

import scala.concurrent.{Await, ExecutionContext, Future}
import scala.util.{Failure, Success}


/**
  * Created by geoffreywatson on 14/07/2017.
  */
@Singleton
class LedgerDAO @Inject() (dbConfigProvider:DatabaseConfigProvider, loanApplicationDAO: LoanApplicationDAO)
                          (implicit ec: ExecutionContext) {

  val dbConfig = dbConfigProvider.get[JdbcProfile]

  import dbConfig._
  import profile.api._


  class AccountTable(tag: Tag) extends Table[Account](tag, "ACCOUNT") {

    def id = column[Int]("ID", O.PrimaryKey)
    def name = column[String]("NAME")
    def group = column[String]("AC_GROUP")
    def * = (id, name, group) <> (Account.tupled, Account.unapply)
  }

  val accounts = TableQuery[AccountTable]
  val companies = TableQuery[CompanyTable]
  val userComps = TableQuery[UserCompanyTable]

  def accountIdExists(id: Int): Boolean = {
    val query = accounts.filter(_.id === id).exists.result
    Await.result(db.run(query), scala.concurrent.duration.Duration(1, "seconds"))
  }

  def insertAccount(account: Account): Unit = {
    db.run(accounts += (account)).map(_ => ())
  }

  /**
    *
    * @param tag
    */
  class JournalLineTable(tag: Tag) extends Table[JournalLine](tag, "JOURNAL_LINE") {

    def id = column[Long]("ID", O.PrimaryKey)
    def jeId = column[Long]("JE_ID")
    def aId = column[Int]("A_ID")
    def amount = column[BigDecimal]("AMOUNT")
    def memo = column[Option[String]]("MEMO")
    def laId = column[Option[Long]]("LA_ID")
    def je = foreignKey("je_fk", jeId, journalLines)(_.id)
    def accId = foreignKey("accId_fk", aId, accounts)(_.id)

    def * = (id, jeId, aId, amount, memo, laId) <> (JournalLine.tupled, JournalLine.unapply)
  }



  class JournalEntryTable(tag: Tag) extends Table[JournalEntry](tag, "JOURNAL_ENTRY") {

    def id = column[Long]("ID", O.PrimaryKey, O.AutoInc)
    def created = column[java.sql.Timestamp]("CREATED")
    def entryDate = column[java.sql.Date]("ENTRY_DATE")
    def * = (id, created, entryDate) <> (JournalEntry.tupled, JournalEntry.unapply)

  }

  val journalLines = TableQuery[JournalLineTable]
  val journalEntries = TableQuery[JournalEntryTable]
  val loanApplications = TableQuery[LoanApplicationTable]



  /**
    * insert a complete journal entry comprising an entry date and some JournalLines. First, insert the JournalEntry
    * and get back the id generated by the db, then use the returned id to insert rows of JournalLines
    * (the id is used as a foreign key in the db).
    *
    * @param je
    */
  def insertJournalEntry(je: CompleteJournalEntry): Unit = {
    val action = insertJeQuery += JournalEntry(0, new Timestamp(System.currentTimeMillis()), Date.valueOf(je.entryDate))
    val futJe = db.run(action)
    val id = Await.result(futJe, scala.concurrent.duration.Duration(1, "seconds")).id
    for (l <- je.journalEntryLines) {
      db.run(journalLines += JournalLine(0, id, l.accId, l.amount, l.memo, l.laId)).map(_ => ())
    }
  }


  def getCompanyName(lId:Long):String = {
    def query(id:Long) = for {
      ((l, uc), c) <- (loanApplications.filter(_.id === id) join userComps on (_.userCoID === _.id)
        join companies on (_._2.cid === _.id))
    } yield (c.name)
    val fut:Future[Option[String]] = db.run(query(lId).result.headOption)
    Await.result(fut,scala.concurrent.duration.Duration(1,"seconds")) match {
      case Some(s) =>
        println("company name in get co name: " + s)
        s
      case None => ""
    }
  }

  val insertJeQuery = journalEntries returning journalEntries.map(_.id) into ((je, id) => je.copy(id = id))

  def insertJournalEntry(entryDate:LocalDate,drAcc:Int,crAcc:Int,amount:BigDecimal,memo:Option[String],lId:Option[Long]): Unit ={
    val memo2:String = lId match {
      case Some(id) => getCompanyName(id)
      case None => ""
    }
    val memo1:String = memo match {
      case Some(m) => m + " -- " + memo2
      case None => ""
    }
    val je = CompleteJournalEntry(entryDate,
      JournalLine(0,0,drAcc,amount,Some(memo1),lId) ::
      JournalLine(0,0,crAcc,-amount,Some(memo1),lId) :: Nil
    )
    val action = insertJeQuery += JournalEntry(0,new Timestamp(System.currentTimeMillis()), Date.valueOf(entryDate))
    db.run(action) onComplete {
      case Success(jeId) => for(l <- je.journalEntryLines){
        db.run(journalLines += JournalLine(0,jeId.id,l.accId,l.amount,l.memo,l.laId))
      }
    }
  }

  /**
    * Disburse funds to the customer. Retrieve the company name associated with the given loanId and then construct a
    * journal entry with the loan amount and the company name which is inserted intJournalLine.
    *
    * @param loanId
    */
  def disburseLoan(loanId: Long): Unit = {
    val entryDate = FinOps.setDrawdownDate(LocalDate.now)
    db.run(loanApplications.filter(_.id===loanId).map(_.amount).result.headOption) onComplete{
      case Success(amount) => insertJournalEntry(entryDate,1200,1050,amount match {
        case Some(x) => x
      },Some("drawdown"),Some(loanId))
        accrueInterest(loanId,entryDate)
        loanApplicationDAO.updateStatus(loanId,"Drawndown")
    }
  }



  def loanBalance(id:Long,date:LocalDate): BigDecimal = {

    def query(id:Long,date:LocalDate) = for {
      ((jl),je) <- (journalLines.filter(c => c.aId === 1200 && c.laId === id)
        join journalEntries.filter(_.entryDate <= Date.valueOf(date)) on (_.jeId===_.id))
    } yield (jl.amount)

    val a:Future[Seq[BigDecimal]] = db.run(query(id,date).result)
    a onComplete {
      case Success(v) => (BigDecimal(0) /: v)(_ + _)
      case Failure(t) => println("an error occured" + t)
    }
    ???
  }






  def accrueInterest(id:Long,entryDate:LocalDate)  = {
    def query(id:Long,date:LocalDate) = for {
      ((jl),je) <- (journalLines.filter(c => c.aId === 1200 && c.laId === id)
        join journalEntries.filter(_.entryDate <= Date.valueOf(date)) on (_.jeId===_.id))
    } yield (jl.amount)

    val a:Future[Seq[BigDecimal]] = db.run(query(id,entryDate).result)
    a onComplete {
      case Success(v) => {
        val loanBalance = (BigDecimal(0) /: v)(_ + _)
        val apr = db.run(loanApplications.filter(_.id===id).map(_.offerAPR).result.headOption) onComplete {
          case Success(Some(r)) => r match {
            case Some(apr) => insertJournalEntry(entryDate,1600,4000,apr/365 * loanBalance,Some("interest accrual"),Some(id))
            case None => throw new Exception("error")
          }
          case Failure(t) => println("error: " + t)
        }
      }
      case Failure(t) => println("an error occured" + t)
    }
  }





}


