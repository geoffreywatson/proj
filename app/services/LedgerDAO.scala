package services

import java.sql.{Date, Timestamp}
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.time.temporal.ChronoUnit
import javax.inject.{Inject, Singleton}

import com.mysql.jdbc.PacketTooBigException
import play.api.Logger._
import models._
import play.api.Logger
import play.api.db.slick.DatabaseConfigProvider
import slick.driver.JdbcProfile
import slick.model.Column

import scala.collection.mutable.ListBuffer
import scala.concurrent.{Await, ExecutionContext, Future}
import scala.io.Source
import scala.util.{Failure, Success}
import scala.concurrent.duration._


/**
  * Created by geoffreywatson on 14/07/2017.
  */
@Singleton
class LedgerDAO @Inject() (dbConfigProvider:DatabaseConfigProvider, loanApplicationDAO: LoanApplicationDAO)
                          (implicit ec: ExecutionContext) {

  case class LineConstructor(date:LocalDate,draw:BigDecimal,int:BigDecimal,pmt:BigDecimal)

  val dbConfig = dbConfigProvider.get[JdbcProfile]

  import dbConfig._
  import profile.api._


  class AccountTable(tag: Tag) extends Table[Account](tag, "ACCOUNT") {

    def id = column[Int]("ID", O.PrimaryKey)
    def name = column[String]("NAME")
    def group = column[String]("AC_GROUP")

    def * = (id, name, group) <> (Account.tupled, Account.unapply)
  }

  val accounts = TableQuery[AccountTable]
  val companies = TableQuery[CompanyTable]
  val userComps = TableQuery[UserCompanyTable]

  def accountIdExists(id: Int): Boolean = {
    val query = accounts.filter(_.id === id).exists.result
    Await.result(db.run(query), Duration(1, SECONDS))
  }

  def insertAccount(account: Account): Unit = {
    db.run(accounts += (account)).map(_ => ())
  }

  /**
    *
    * @param tag
    */
  class JournalLineTable(tag: Tag) extends Table[JournalLine](tag, "JOURNAL_LINE") {

    def id = column[Long]("ID", O.PrimaryKey)
    def jeId = column[Long]("JE_ID")
    def aId = column[Int]("A_ID")
    def amount = column[BigDecimal]("AMOUNT",O.SqlType("decimal(10,2)"))
    def memo = column[Option[String]]("MEMO")
    def laId = column[Option[Long]]("LA_ID")
    def je = foreignKey("je_fk", jeId, journalLines)(_.id)
    def accId = foreignKey("accId_fk", aId, accounts)(_.id)

    def * = (id, jeId, aId, amount, memo, laId) <> (JournalLine.tupled, JournalLine.unapply)
  }


  class JournalEntryTable(tag: Tag) extends Table[JournalEntry](tag, "JOURNAL_ENTRY") {

    def id = column[Long]("ID", O.PrimaryKey, O.AutoInc)
    def created = column[java.sql.Timestamp]("CREATED")
    def entryDate = column[java.sql.Date]("ENTRY_DATE")

    def * = (id, created, entryDate) <> (JournalEntry.tupled, JournalEntry.unapply)
  }

  val journalLines = TableQuery[JournalLineTable]
  val journalEntries = TableQuery[JournalEntryTable]
  val loanApplications = TableQuery[LoanApplicationTable]





  /**
    * insert a complete journal entry comprising an entry date and some JournalLines. First, insert the JournalEntry
    * and get back the id generated by the db, then use the returned id to insert rows of JournalLines
    * (the id is used as a foreign key in the db).
    *
    * @param je
    */
  def insertJournalEntry(je: CompleteJournalEntry): Unit = {
    val action = insertJeQuery += JournalEntry(0, new Timestamp(System.currentTimeMillis()), Date.valueOf(je.entryDate))
    val futJe = db.run(action)
    val id = Await.result(futJe, Duration(1, SECONDS)).id
    for (l <- je.journalEntryLines) {
      db.run(journalLines += JournalLine(0, id, l.accId, l.amount, l.memo, l.laId)).map(_ => ())
    }
  }


  def getCompanyName(lId: Long): String = {
    def query(id: Long) = for {
      ((l, uc), c) <- (loanApplications.filter(_.id === id) join userComps on (_.userCoID === _.id)
        join companies on (_._2.cid === _.id))
    } yield (c.name)

    val fut: Future[Option[String]] = db.run(query(lId).result.headOption)
    Await.result(fut, Duration(1, SECONDS)) match {
      case Some(coName) => coName
      case None => ""
    }
  }

  val insertJeQuery = journalEntries returning journalEntries.map(_.id) into ((je, id) => je.copy(id = id))

  def insertJournalEntry(entryDate: LocalDate, drAcc: Int, crAcc: Int, amount: BigDecimal, memo: Option[String], lId: Option[Long]): Unit = {
    val memo2: String = lId match {
      case Some(id) => getCompanyName(id)
      case None => ""
    }
    val memo1: String = memo match {
      case Some(m) => m + " -- " + memo2
      case None => ""
    }
    val je = CompleteJournalEntry(entryDate,
      JournalLine(0, 0, drAcc, amount, Some(memo1), lId) ::
        JournalLine(0, 0, crAcc, -amount, Some(memo1), lId) :: Nil
    )
    val action = insertJeQuery += JournalEntry(0, new Timestamp(System.currentTimeMillis()), Date.valueOf(entryDate))
    db.run(action) onComplete {
      case Success(jeId) => for (l <- je.journalEntryLines) {
        db.run(journalLines += JournalLine(0, jeId.id, l.accId, l.amount, l.memo, l.laId))
      }
    }
  }

  /**
    * Disburse funds to the customer. Retrieve the company name associated with the given loanId and then construct a
    * journal entry with the loan amount and the company name which is inserted intJournalLine.
    *
    * @param loanId
    */
  def disburseLoan(loanId: Long): Unit = {
    val entryDate = FinOps.setDrawdownDate(LocalDate.now)
    db.run(loanApplications.filter(_.id === loanId).map(x => (x.amount, x.offerAPR)).result.headOption).map { i =>
      i match {
        case Some(p) => insertJournalEntry(entryDate, 1200, 1050, p._1, Some("drawdown"), Some(loanId))
          accrueInterest(loanId, entryDate, p._2 match {
            case Some(r) => r
          })
          loanApplicationDAO.updateStatus(loanId, "Drawndown")
      }
    }
  }

  def loanBalance(id: Long, date: LocalDate): BigDecimal = {

    def query(id: Long, date: LocalDate) = for {
      ((jl), je) <- (journalLines.filter(c => c.aId === 1200 && c.laId === id)
        join journalEntries.filter(_.entryDate <= Date.valueOf(date)) on (_.jeId === _.id))
    } yield (jl.amount)

    val a: Future[Seq[BigDecimal]] = db.run(query(id, date).result)
    a onComplete {
      case Success(v) => (BigDecimal(0) /: v) (_ + _)
      case Failure(t) => println("an error occured" + t)
    }
    ???
  }


  /**
    *
    * @param id
    * @param entryDate
    */

  def accrueInterest(id: Long, entryDate: LocalDate, apr:BigDecimal) = {

    def query(id:Long, date:LocalDate) = for {
      ((jl), je) <- (journalLines.filter(c => c.aId === 1200 && c.laId === id)
        join journalEntries.filter(_.entryDate <= Date.valueOf(date)) on (_.jeId === _.id))
    } yield (jl.amount)

   db.run(query(id, entryDate).result).map{ x =>
     val loanBal = (BigDecimal(0) /: x) (_+_)
     if(loanBal > 0) insertJournalEntry(entryDate,1600,4000,apr/365 * loanBal,Some("interest accrual"), Some(id))
   }
  }


  def actualAmortSched(id:Long):Future[List[AmortizationLine]]= {
    val query = (for {
      (jl, je) <- (journalLines.filter(x => x.laId === id && x.aId === 1200)
        join journalEntries on (_.jeId === _.id))
    } yield (jl, je)).sortBy(_._2.entryDate.asc)
    db.run(query.result).map { jLines => dailySchedule(jLines)
    }
  }

  private def dailySchedule(seq:Seq[(JournalLine,JournalEntry)]):List[AmortizationLine] = {
    val lc = toLineConstructor(seq)
    def next(remain:List[LineConstructor],sched:List[AmortizationLine]):List[AmortizationLine] = {
      ChronoUnit.DAYS.between(sched.head.date,LocalDate.now) match {
        case 0 => sched.reverse
        case _ => ChronoUnit.DAYS.between(sched.head.date,remain.head.date) match {
          case 1 =>
            val hd = remain.head
            val ebal = sched.head.ebal + hd.draw + hd.int + hd.pmt
            next(remain.tail,AmortizationLine(hd.date,sched.head.ebal,hd.draw,hd.int,hd.pmt,ebal)::sched)
          case _ =>
            val hd = sched.head
            next(remain,AmortizationLine(hd.date.plusDays(1),hd.ebal,0,0,0,hd.ebal)::sched)
        }
      }
    }
    next(lc.tail,AmortizationLine(lc.head.date,0,lc.head.draw,lc.head.int,lc.head.pmt,lc.head.draw)
      ::List[AmortizationLine]())
  }

  /**
    * Consolidate lines with the same date to form a new list
    * @param lines
    * @return
    */
  private def flattenLines(lines:List[LineConstructor]):List[LineConstructor] = {
    def next(remain:List[LineConstructor],sched:List[LineConstructor]):List[LineConstructor]= remain match {
      case Nil => sched
      case hd :: tl => ChronoUnit.DAYS.between(sched.head.date,hd.date) match {
        case 0 => next(remain.tail,LineConstructor(sched.head.date,sched.head.draw + hd.draw,
          sched.head.int + hd.int, sched.head.pmt + hd.pmt) :: sched.tail)
        case _ => next(remain.tail,LineConstructor(hd.date,hd.draw,hd.int,hd.pmt)::sched)
      }
    }
    next(lines.tail,LineConstructor(lines.head.date,lines.head.draw,lines.head.int,lines.head.pmt)::List[LineConstructor]())
  }



  /**
    * convert a tuple of JournalLine and JournalEntry into a LineConstructor. A LineConstructor is an intermediate case class
    * used to prepare the actual Amortization Schedule of a Loan.
    * @param line
    * @return
    */
  private def toLineConstructor(line:(JournalLine,JournalEntry)):LineConstructor={
    val amount = line._1.amount
    val alloc:Tuple3[BigDecimal,BigDecimal,BigDecimal] = line._1.memo match {
      case Some(s) => s match {
        case msg if msg.startsWith("drawdown") => (amount,BigDecimal(0),BigDecimal(0))
        case msg if msg.startsWith("interest") => (BigDecimal(0),amount,BigDecimal(0))
        case msg if msg.startsWith("payment") => (BigDecimal(0),BigDecimal(0),amount)
        case _ => throw new IllegalArgumentException("no match on line memo")
      }
      case None => throw new IllegalArgumentException("Could not match account id")
    }
    LineConstructor(line._2.entryDate.toLocalDate,alloc._1,alloc._2,alloc._3)
  }

  private def toLineConstructor(lines:Seq[(JournalLine,JournalEntry)]):List[LineConstructor]={

    def next(remain:List[(JournalLine,JournalEntry)],sched:List[LineConstructor]):List[LineConstructor]= {
        remain match {
          case Nil => flattenLines(sched)
          case hd :: tl => next(remain.tail,toLineConstructor(hd) :: sched)
          case _ => throw new Exception("Unidentified pattern")
        }
    }
    next(lines.tail.toList,toLineConstructor(lines.head)::List[LineConstructor]())
  }


  def loadData: Unit = {

    Logger.info("Loading Journal Entry Data..")

    loadJournalEntryData.map { i =>
      Logger.info(s"JournalEntry Data Load Complete. Total ${i} rows")

      loadJournalLineData.map { i => Logger.info(s"JournalLine Data Load Complete. Total ${i} rows")
      }
    }
  }


    def loadJournalEntryData:Future[Unit] = {
      val sdf = new SimpleDateFormat("yyyy/MM/dd")
      val source = Source.fromFile("./public/sampledata/journalentrydata.csv")
      val jeList = new ListBuffer[JournalEntry]()
      for (line <- source.getLines().drop(1)) {
        val cols = line.split(",").map(_.trim)
        val je = JournalEntry(0, new Timestamp(System.currentTimeMillis()), new java.sql.Date(sdf.parse(cols(0)).getTime))
        jeList += je
      }
      source.close()
      db.run((journalEntries ++= jeList).transactionally).map{_=>db.run(journalEntries.length.result)
        .map{i=>Logger.info(s"JournalLine DAta Load Complete ${i} rows LOADED")}}

    }

    def loadJournalLineData: Future[Int] = {
      val source = Source.fromFile("./public/sampledata/journallinedata.csv")
      val jlList = new ListBuffer[JournalLine]()
      for (line <- source.getLines().drop(1)) {
        val cols = line.split(",").map(_.trim)
        val jl = JournalLine(0, cols(0).toLong, cols(1).toInt, BigDecimal(cols(2)), Some(cols(3)), Some(cols(4).toLong))
        jlList += jl
      }
      source.close()
      db.run((journalLines ++= jlList).transactionally)
      Thread.sleep(3000)
      db.run(journalLines.length.result)
    }

  /**
    * Calculate interest to date on loans in sample data set. Identify loan applications that have drawn down by selecting
    * rows in JournalLine table that have account id = 1050 (the Loan Disbursement Account). For each loan obtain a list of
    * profiled payment due dates. On each profile payment date, the accumulated daily interest accrual is charged to the loan
    * capital (interest compounded).
    */
  def sampleDataInterestCharge: Unit = {

    Logger.info("Calculating interest on sample loan book...")

    //Query the db to get a list of loans drawn down.
    //SQL EQUIVALENT: SELECT jl.laId, je.entryDate FROM JournalLines jl, JournalEntries je WHERE jl.laId = 1050;

    val query = for {
      ((jl, je), la) <- journalLines.filter(_.aId === 1050) join
        journalEntries on (_.jeId === _.id) join
        loanApplications on (_._1.laId === _.id)
    } yield (jl.laId, je.entryDate, la.offerAPR, la.term)

    //for each loan begin accruing interest on balance outstanding each day since drawdown day until today.

    db.run(query.result).map { a => a.foreach(

      x => loan(
        x._1 match {
      case Some(i) => i
      case None => throw new IllegalArgumentException("ERROR: entryDate when calling loan in LedgerDAO")
      },
        x._2.toLocalDate,
        x._3 match {
        case Some(r) => r
        case None => throw new IllegalArgumentException("")
      }, x._4))
    }

    def loan(id:Long,drawDownDate:LocalDate,apr:BigDecimal,term:Int): Unit = {

      val paymentDates = FinOps.getPaymentDates(drawDownDate,term).tail

      val today = LocalDate.now

      def next(localDate: LocalDate): Unit = {
        if(paymentDates.contains(localDate)) compoundInterest(id,localDate)
        val dateDiff = ChronoUnit.DAYS.between(localDate, today)
        dateDiff match {
          case 0 => accrueInterest(id, localDate, apr)
          case x if (x > 0) => accrueInterest(id, localDate, apr)

            next(localDate.plusDays(1))
          case _ => Logger.info(s"Future dated loan: ${id} drawdown on ${drawDownDate}")
        }
      }

      next(drawDownDate)
    }
  }

  def compoundInterest(id:Long, localDate: LocalDate):Future[Unit] = {

    //Equivalent SQL: SELECT jl.amount FROM journal_lines jl, journal_entry je WHERE jl.je_id = je.id AND
    //jl.a_id = 1600 and jl.la_id = ?
    val query = for{
      (jl,je) <- journalLines.filter(x => x.aId===1600 && x.laId===id) join
        journalEntries on (_.jeId===_.id)
    } yield jl.amount

    //db.run(query.result).map{y => for (l <- y){
      //println(s"LOAN ID: ${id} DATE: ${l._1} AMOUNT: ${l._2}")

    //}
    //}}

    db.run(query.result).map{y =>
      val intBal = (BigDecimal(0) /: y) (_+_)
      //println(s"NOW print the list of y query to get intBal.....FOR LOAN ID: ${id} ON DATE: ${localDate}")
      //y.foreach(println _)
      //println(s"Now the sum of intBal list is: ${intBal}.")
      insertJournalEntry(localDate,1200,1600,intBal,Some("interest charge"),Some(id))
    }}






    def delete: Future[Unit] = {
      Logger.info("Deleting Journal Entry data...")
      db.run(journalLines.delete.transactionally).map { _ => Logger.info("Journal lines Deleted.") }
      db.run(journalEntries.delete.transactionally).map { _ => Logger.info("Journal entries Deleted.") }
      db.run(accounts.delete.transactionally).map { _ => Logger.info("Accounts Deleted.") }
    }

  def interestonFakeData = {

    Logger.info("Interest on Fake Data CALLED...")

    val fut: Future[Seq[Option[Long]]] = db.run(journalLines.filter(x => (x.aId === 1050 && x.memo.startsWith("drawdown"))).map(_.laId).result)
    fut.map { f =>
      println(s"TOTAL LOANS DRAWNDOWN: ${f.length}")
      for (l <- f) {
        l match {
          case Some(i) =>
            Logger.info(s"Now DOING LOAN ID: ${i}")
            debtor(i)
          case None => Logger.error("Loan ID missing")
        }
      }
    }

    def debtor(id: Long) = {



      val query = (for {
        (jl, je) <- journalLines.filter(x => x.laId === id && x.aId === 1200) join
          journalEntries on (_.jeId === _.id)
      } yield (je.entryDate, jl.amount)).sortBy(_._1.asc)

      val fut: Future[Seq[(Date, BigDecimal)]] = db.run(query.result)
      val d = Await.result(fut, Duration(1, SECONDS))
      val init: List[(LocalDate, BigDecimal)] = d.toList.map(x => (x._1.toLocalDate, x._2))

      //init.foreach(x=> Logger.debug(s"IN Debtor LOAN ID ${id} DATE AND AMOUNT ${x._1} ${x._2}"))






      def intCalc(sched:List[AmortizationLine],accInt:BigDecimal,pmt:BigDecimal,apr:BigDecimal):BigDecimal={
        (sched.head.ebal + accInt + pmt) * apr/365
      }

      def lineFac(sched:List[AmortizationLine],accInt:BigDecimal,
                  remain:List[(LocalDate,BigDecimal)],apr:BigDecimal, dueDates:List[LocalDate]): AmortizationLine ={
        val nextDay = sched.head.date.plusDays(1)
        val pmt = if(nextDay.isEqual(remain.head._1)) remain.head._2 else BigDecimal(0)
        val compInt = if(dueDates.contains(nextDay)) accInt else BigDecimal(0)
        ???

      }


      def accrue(init: List[(LocalDate, BigDecimal)],dueDates:List[LocalDate],apr:BigDecimal): List[AmortizationLine] = {
        def next(sched:List[AmortizationLine],
                 remain:List[(LocalDate,BigDecimal)],accInt:BigDecimal): List[AmortizationLine]={
          val nextDay = sched.head.date.plusDays(1)
            if(id==17) Logger.debug(s"ID ${id} DATE: ${sched.head.date} OBAL: ${sched.head.obal} DRAW: ${sched.head.drawdown}" +
              s" INT ${sched.head.int} PMT ${sched.head.pmt} EBAL ${sched.head.ebal}")
          nextDay.isEqual(LocalDate.now) match {
            case true => sched.reverse
            case false => dueDates.contains(nextDay) match {
              case true => // it's a compounding day
                if(nextDay.isEqual(remain.head._1)){
                  // it's also a day when a payment was made
                  val interest = intCalc(sched,accInt,remain.head._2,apr)
                  val ebal = sched.head.ebal + interest + accInt + remain.head._2
                  val line = AmortizationLine(nextDay,sched.head.ebal,
                    BigDecimal(0),interest + accInt,remain.head._2,ebal)
                  next(line::sched,remain.tail,BigDecimal(0))
              } else { // apply payment and accrue interest
                  val interest = intCalc(sched,BigDecimal(0),remain.head._2,apr)
                  val ebal = sched.head.ebal + interest + remain.head._2
                  val line = AmortizationLine(nextDay,sched.head.ebal,BigDecimal(0),BigDecimal(0),remain.head._2,ebal)
                  next(line::sched,remain.tail,accInt + interest)
                }
              case false => //normal accrual day
                val interest = intCalc(sched,BigDecimal(0),BigDecimal(0),apr)
                val line = AmortizationLine(nextDay,sched.head.ebal,BigDecimal(0),BigDecimal(0),
                  BigDecimal(0),sched.head.ebal)
                next(line::sched,remain,accInt+interest)
            }
          }
        }
        val line = AmortizationLine(init.head._1,BigDecimal(0),init.head._2,BigDecimal(0),BigDecimal(0),init.head._2)
        val interest = intCalc(line::Nil,BigDecimal(0),BigDecimal(0),apr)
        next(line::Nil,init.tail,interest)
      }
      val aprTerm = Await.result(db.run(loanApplications.filter(_.id===id).map(x=>(x.offerAPR,x.term))
        .result.headOption),Duration(1,SECONDS))

      val apr:BigDecimal = aprTerm.map(_._1.get).get

      val term:Int = aprTerm.map(_._2).get

      val dueDates = FinOps.getPaymentDates(init.head._1,term)

      //Logger.debug(s"APR: ${apr} term ${term}")

      val list = accrue(init,dueDates.tail,apr)

      //println("READY FOR ACTION!! FOR LOAD ID: " + id)

      def formatter(x:BigDecimal)={
        java.text.NumberFormat.getCurrencyInstance.format(x)
      }

      list.foreach(x=> Logger.debug(s" LOAN: ${id} DATE: ${x.date} OBAL: ${formatter(x.obal)} " +
        s"DRAW: ${formatter(x.drawdown)} INT: ${formatter(x.int)} PMT: ${formatter(x.pmt)} EBAL: ${formatter(x.ebal)}"))
    }









  }

}







